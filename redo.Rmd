---
title: "redo analysis"
author: "Andrew MacDonald"
date: "April 8, 2016"
output: pdf_document
---

```{r}
remake::dump_environment()
inverts_tts_fin
zoops_tts_fin
```

Let's choose only a few blocks to get started:

```{r}
blks <- c("Baker", "Eccleson")

is_in <- which(inverts_tts_fin$factors$Block %in% blks)

inverts_tts_fin$factors <- inverts_tts_fin$factors[is_in,]
inverts_tts_fin$taxa <- inverts_tts_fin$taxa[is_in,]

is_in <- which(zoops_tts_fin$factors$Block %in% blks)

zoops_tts_fin$factors <- zoops_tts_fin$factors[is_in,]
zoops_tts_fin$taxa <- zoops_tts_fin$taxa[is_in,]
```

and combine them:


Actually, what needs to happen here is a difference kind of _split_ in the list structure: specifcally, I want a list as long as the number of blocks (2 in this case, 5 in real life). I want each element to contain a `$factors` and a `$taxa` element. `purrr` probably has the perfect tool if only I can find it.

```{r}

library(purrr)

inverts_tts_fin %>% 
  lapply(split, f = .[["factors"]][["Block"]]) %>% 
  transpose()


```

That looks like the correct operation! This `transpose()` performs exactly the operation we want.

```{r}

f <- . %>% 
  lapply(split, f = .[["factors"]][["Block"]]) %>% 
  transpose()

invert_zoops <-  
  list(inverts = inverts_tts_fin %>% f,
       zoops   = zoops_tts_fin %>% f)

```

So far so good. Now let's build the PERMANOVA response:

```{r}
AdonisData <- function(Data, .strata = Data[["factors"]]$Block, ...){  
  adonis(Data[["taxa"]] ~ species , data = Data[["factors"]], strata = .strata, ...)
}

adonis_list <- invert_zoops %>% 
  at_depth(2, AdonisData)

adonis_list %>% 
  map(. %>% map_dbl(~.x[["aov.tab"]][["R2"]][[1]])) %>% 
  map_df(~data_frame(Block = names(.x), rsq = .x), .id = "grp")

```

